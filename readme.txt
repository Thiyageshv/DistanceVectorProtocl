Distance Vector Routing :  How to invoke? The client.py is executed asPython client.py <listening port> <timeout interval to send dv updates [ <IP address of neighbor 1, listening port of  neighbor 1 , weight of path to neighbor 1 > ;  <IP address of neighbor 2 , listening port of  neighbor 2 , weight of path to neighbor 2 >……. ] Values in [] are optional. The client.py has to be invoked in the above manner in all the necessary systems with right arguments. The systems will then come to an understanding and get stabilized with the routes. Algorithm and data structures used :            The algorithm uses 4 threads and 2 sockets. 1. Senderthread to send distance vector updates after specific intervals (time interval being given by the user) 2. Receiverthread to listen for updates from its neighbors and store the received distance vector in a hash table. 3. Menuthread where the user can input the SHOWRT, LINKUP, LINKDOWN and CLOSE commands and appropriate action is taken. 4. Timnerthread to keep checking if a particular neighbor has been idle for more than 3*TIMEOUT seconds.5. Read socket that is used in the receiverthread for listening.6. Write socket that is used in the senderthread for sending triggered updates. The initialization starts with creating an hash table with keys as neighbor id’s and the values as their corresponding class object. The class object contains the following details. - Ip address- Listeningport - Status 1 = up, 0 = down or closed- Last update = time when the last distance update vector was received from the neighbor Each client is identified by their ip address and listening port number127.0.0.1-300 is an ID of client listening on port 300. 127.0.0.1-600 is ID for a port listening on port 600 and so on. The data structure: The routing table uses a hash map inside a hash map structure. The outer keys are the id’s of each machine in the network. The value is the corresponding id’s distance vector which is in turn a hash map (id , weight) . The local client maintains a distance vector array where it computes and stores the cost to each ID in the network. The viavec is a hash map that gives the next hop ID of the client for a particular destination. Protocol used for distance vector updates: Each value in the distance vector takes the following syntax <sender listening port> destination id:weight| The “|” is used as a delimiter when we pass the distance vector as a string.  The receiver client splits them based on the delimiter and gets individual terms in the distance vector. It also gets the sender’s listening port by splitting the term by (“ “ ). It then combines the address and the sender’s listening port to form the senderid. It goes on to store the details of the sender ID in its hash map structure which is used by the senderthread to check if there could be any changes in the distance vector values using Bellman-Ford algorithm.Use of triggered updates: In a move to solve the count to infinity problem, triggered updates are used (where the LINKDOWN message is sent quickly instead of waiting for the timeout). But still we may face problems. Also it is important to note that it takes some time detect an unreachable client. 256 is used as the maximum weight value. If the weight of a path to a particular client exceeds 256, then the path is deemed unreachable. CLOSE connections : Once the timerthread detects any idle neighbor, it attempts to set the cost of the neighbor to 256 and status to 0 (by sending a LINKDOWN self message to the receiver thread along with the node id that went down. It then deletes the neighbor’s entries from the table after 2*TIMEOUT seconds (time given to stabilize) 	